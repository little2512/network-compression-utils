<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Compression Utils - Browser Tests</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            margin: 0 0 10px 0;
            font-size: 2.5em;
            font-weight: 300;
        }

        .header p {
            margin: 0;
            opacity: 0.9;
            font-size: 1.1em;
        }

        .content {
            padding: 30px;
        }

        .test-section {
            margin-bottom: 30px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            overflow: hidden;
        }

        .test-section-header {
            background: #f8f9fa;
            padding: 15px 20px;
            border-bottom: 1px solid #e0e0e0;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s;
        }

        .test-section-header:hover {
            background: #e9ecef;
        }

        .test-section-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #333;
            margin: 0;
        }

        .test-section-toggle {
            font-size: 0.8em;
            color: #666;
            transition: transform 0.2s;
        }

        .test-section.expanded .test-section-toggle {
            transform: rotate(180deg);
        }

        .test-section-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .test-section.expanded .test-section-content {
            max-height: 2000px;
        }

        .test-controls {
            padding: 20px;
            background: #fafafa;
        }

        .test-result {
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }

        .test-result.success {
            background: #d4edda;
            border-top: 1px solid #c3e6cb;
            color: #155724;
        }

        .test-result.error {
            background: #f8d7da;
            border-top: 1px solid #f5c6cb;
            color: #721c24;
        }

        .test-result.info {
            background: #d1ecf1;
            border-top: 1px solid #bee5eb;
            color: #0c5460;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        button.secondary {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-indicator.idle {
            background: #6c757d;
        }

        .status-indicator.running {
            background: #ffc107;
            animation: pulse 1s infinite;
        }

        .status-indicator.success {
            background: #28a745;
        }

        .status-indicator.error {
            background: #dc3545;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .info-box {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 0 4px 4px 0;
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .metric-card {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 15px;
            text-align: center;
        }

        .metric-value {
            font-size: 1.5em;
            font-weight: 700;
            color: #667eea;
        }

        .metric-label {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Network Compression Utils</h1>
            <p>Browser-Based Testing Suite</p>
        </div>

        <div class="content">
            <div class="info-box">
                <strong>è¯´æ˜:</strong> è¿™ä¸ªé¡µé¢æä¾›äº†æµè§ˆå™¨ç«¯æµ‹è¯•ç•Œé¢ï¼Œç”¨äºéªŒè¯ç½‘ç»œå‹ç¼©å·¥å…·çš„åŠŸèƒ½ã€‚
                æ‰€æœ‰æµ‹è¯•éƒ½åœ¨çœŸå®çš„æµè§ˆå™¨ç¯å¢ƒä¸­è¿è¡Œï¼Œç¡®ä¿åº“åœ¨å®¢æˆ·ç«¯çš„å…¼å®¹æ€§å’Œæ€§èƒ½ã€‚
            </div>

            <!-- Compression Tests -->
            <div class="test-section" id="compression-tests">
                <div class="test-section-header">
                    <h3 class="test-section-title">
                        <span class="status-indicator idle" id="compression-status"></span>
                        å‹ç¼©åŠŸèƒ½æµ‹è¯•
                    </h3>
                    <span class="test-section-toggle">â–¼</span>
                </div>
                <div class="test-section-content">
                    <div class="test-controls">
                        <button onclick="runBasicCompressionTest()">åŸºç¡€å‹ç¼©æµ‹è¯•</button>
                        <button onclick="runLargeDataTest()">å¤§æ•°æ®å‹ç¼©æµ‹è¯•</button>
                        <button onclick="runDecompressionTest()">è§£å‹ç¼©æµ‹è¯•</button>
                        <button onclick="runEdgeCaseTest()" class="secondary">è¾¹ç•Œæƒ…å†µæµ‹è¯•</button>
                    </div>
                    <div class="test-result" id="compression-result">
                        ç‚¹å‡»ä¸Šé¢çš„æŒ‰é’®å¼€å§‹æµ‹è¯•...
                    </div>
                </div>
            </div>

            <!-- Network-Aware Tests -->
            <div class="test-section" id="network-tests">
                <div class="test-section-header">
                    <h3 class="test-section-title">
                        <span class="status-indicator idle" id="network-status"></span>
                        ç½‘ç»œæ„ŸçŸ¥æµ‹è¯•
                    </h3>
                    <span class="test-section-toggle">â–¼</span>
                </div>
                <div class="test-section-content">
                    <div class="test-controls">
                        <button onclick="runNetworkDetectionTest()">ç½‘ç»œæ£€æµ‹æµ‹è¯•</button>
                        <button onclick="simulateSlowNetwork()">æ¨¡æ‹Ÿæ…¢ç½‘ç»œ</button>
                        <button onclick="simulateFastNetwork()">æ¨¡æ‹Ÿå¿«ç½‘ç»œ</button>
                        <button onclick="runNetworkAdaptiveTest()" class="secondary">è‡ªé€‚åº”å‹ç¼©æµ‹è¯•</button>
                    </div>
                    <div class="test-result" id="network-result">
                        ç‚¹å‡»ä¸Šé¢çš„æŒ‰é’®å¼€å§‹æµ‹è¯•...
                    </div>
                </div>
            </div>

            <!-- Format Conversion Tests -->
            <div class="test-section" id="format-tests">
                <div class="test-section-header">
                    <h3 class="test-section-title">
                        <span class="status-indicator idle" id="format-status"></span>
                        æ ¼å¼è½¬æ¢æµ‹è¯•
                    </h3>
                    <span class="test-section-toggle">â–¼</span>
                </div>
                <div class="test-section-content">
                    <div class="test-controls">
                        <button onclick="testURLSearchParams()">URLSearchParamsè½¬æ¢</button>
                        <button onclick="testFormData()">FormDataè½¬æ¢</button>
                        <button onclick="testJSONFormat()">JSONæ ¼å¼æµ‹è¯•</button>
                        <button onclick="testStringFormat()" class="secondary">å­—ç¬¦ä¸²æ ¼å¼æµ‹è¯•</button>
                    </div>
                    <div class="test-result" id="format-result">
                        ç‚¹å‡»ä¸Šé¢çš„æŒ‰é’®å¼€å§‹æµ‹è¯•...
                    </div>
                </div>
            </div>

            <!-- Performance Metrics -->
            <div class="test-section" id="performance-tests">
                <div class="test-section-header">
                    <h3 class="test-section-title">
                        <span class="status-indicator idle" id="performance-status"></span>
                        æ€§èƒ½æŒ‡æ ‡æµ‹è¯•
                    </h3>
                    <span class="test-section-toggle">â–¼</span>
                </div>
                <div class="test-section-content">
                    <div class="test-controls">
                        <button onclick="runPerformanceBenchmark()">æ€§èƒ½åŸºå‡†æµ‹è¯•</button>
                        <button onclick="runMemoryTest()">å†…å­˜ä½¿ç”¨æµ‹è¯•</button>
                        <button onclick="runBatchTest()">æ‰¹é‡æ“ä½œæµ‹è¯•</button>
                        <button onclick="showPerformanceStats()" class="secondary">æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯</button>
                    </div>
                    <div class="test-result" id="performance-result">
                        ç‚¹å‡»ä¸Šé¢çš„æŒ‰é’®å¼€å§‹æµ‹è¯•...
                    </div>
                </div>
            </div>

            <!-- Overall Metrics -->
            <div class="metrics">
                <div class="metric-card">
                    <div class="metric-value" id="total-tests">0</div>
                    <div class="metric-label">æ€»æµ‹è¯•æ•°</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="passed-tests">0</div>
                    <div class="metric-label">é€šè¿‡æµ‹è¯•</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="failed-tests">0</div>
                    <div class="metric-label">å¤±è´¥æµ‹è¯•</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="compression-ratio">0%</div>
                    <div class="metric-label">å¹³å‡å‹ç¼©ç‡</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load LZ-String library -->
    <script src="node_modules/lz-string/libs/lz-string.min.js"></script>

    <!-- Load our browser-bundled library -->
    <script src="dist/browser.js"></script>

    <script>
        // Global test state
        let totalTests = 0;
        let passedTests = 0;
        let failedTests = 0;
        let totalCompression = 0;
        let compressionCount = 0;
        let compressionUtils = new NetworkCompressionUtils();

        // Toggle test sections
        document.querySelectorAll('.test-section-header').forEach(header => {
            header.addEventListener('click', () => {
                const section = header.parentElement;
                section.classList.toggle('expanded');
            });
        });

        // Expand first section by default
        document.getElementById('compression-tests').classList.add('expanded');

        // Utility functions
        function updateStatus(sectionId, status) {
            const indicator = document.getElementById(`${sectionId}-status`);
            indicator.className = `status-indicator ${status}`;
        }

        function setResult(resultId, content, type = 'info') {
            const result = document.getElementById(resultId);
            result.textContent = content;
            result.className = `test-result ${type}`;
        }

        function updateMetrics() {
            document.getElementById('total-tests').textContent = totalTests;
            document.getElementById('passed-tests').textContent = passedTests;
            document.getElementById('failed-tests').textContent = failedTests;
            const avgRatio = compressionCount > 0 ? (totalCompression / compressionCount * 100).toFixed(1) : 0;
            document.getElementById('compression-ratio').textContent = avgRatio + '%';
        }

        function recordTest(passed, compressionRatio = 0) {
            totalTests++;
            if (passed) passedTests++;
            else failedTests++;

            if (compressionRatio > 0) {
                totalCompression += compressionRatio;
                compressionCount++;
            }

            updateMetrics();
        }

        // Test functions
        async function runBasicCompressionTest() {
            updateStatus('compression', 'running');
            setResult('compression-result', 'æ­£åœ¨è¿è¡ŒåŸºç¡€å‹ç¼©æµ‹è¯•...', 'info');

            try {
                const testData = {
                    message: 'test_message_12345'.repeat(200),
                    content: 'A'.repeat(1000),
                    details: {
                        pattern: 'repeated_pattern_xyz'.repeat(100)
                    }
                };

                const startTime = performance.now();
                const result = compressionUtils.compress(testData);
                const endTime = performance.now();

                if (result.success) {
                    const compressionTime = (endTime - startTime).toFixed(2);
                    const output = `
âœ… åŸºç¡€å‹ç¼©æµ‹è¯•é€šè¿‡

åŸå§‹å¤§å°: ${result.originalSize} å­—èŠ‚
å‹ç¼©åå¤§å°: ${result.compressedSize} å­—èŠ‚
å‹ç¼©ç‡: ${(result.compressionRatio * 100).toFixed(1)}%
å‹ç¼©æ—¶é—´: ${compressionTime} æ¯«ç§’
ä½¿ç”¨ç®—æ³•: ${result.algorithm}

å‹ç¼©æˆåŠŸ: ${result.success}
é”™è¯¯ä¿¡æ¯: ${result.error || 'æ— '}
                    `.trim();

                    setResult('compression-result', output, 'success');
                    recordTest(true, result.compressionRatio);
                } else {
                    const output = `
âŒ åŸºç¡€å‹ç¼©æµ‹è¯•å¤±è´¥

åŸå§‹å¤§å°: ${result.originalSize} å­—èŠ‚
å‹ç¼©åå¤§å°: ${result.compressedSize} å­—èŠ‚
é”™è¯¯ä¿¡æ¯: ${result.error || 'æœªçŸ¥é”™è¯¯'}
                    `.trim();

                    setResult('compression-result', output, 'error');
                    recordTest(false);
                }
            } catch (error) {
                setResult('compression-result', `âŒ æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                recordTest(false);
            }

            updateStatus('compression', 'success');
        }

        async function runLargeDataTest() {
            updateStatus('compression', 'running');
            setResult('compression-result', 'æ­£åœ¨è¿è¡Œå¤§æ•°æ®å‹ç¼©æµ‹è¯•...', 'info');

            try {
                const largeData = {
                    data: 'x'.repeat(50000), // 50KB
                    metadata: Array(1000).fill('large_data_metadata'),
                    timestamp: new Date().toISOString()
                };

                const startTime = performance.now();
                const result = compressionUtils.compress(largeData);
                const endTime = performance.now();

                const compressionTime = (endTime - startTime).toFixed(2);
                const output = `
${result.success ? 'âœ…' : 'âŒ'} å¤§æ•°æ®å‹ç¼©æµ‹è¯•

æ•°æ®å¤§å°: ${(result.originalSize / 1024).toFixed(1)} KB
å‹ç¼©åå¤§å°: ${(result.compressedSize / 1024).toFixed(1)} KB
å‹ç¼©ç‡: ${result.success ? (result.compressionRatio * 100).toFixed(1) + '%' : 'N/A'}
å‹ç¼©æ—¶é—´: ${compressionTime} æ¯«ç§’
ç®—æ³•: ${result.algorithm}

æ€§èƒ½è¯„ä¼°: ${compressionTime < 100 ? 'ä¼˜ç§€' : compressionTime < 500 ? 'è‰¯å¥½' : 'éœ€è¦ä¼˜åŒ–'}
                `.trim();

                setResult('compression-result', output, result.success ? 'success' : 'error');
                recordTest(result.success, result.compressionRatio);
            } catch (error) {
                setResult('compression-result', `âŒ æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                recordTest(false);
            }

            updateStatus('compression', 'success');
        }

        async function runDecompressionTest() {
            updateStatus('compression', 'running');
            setResult('compression-result', 'æ­£åœ¨è¿è¡Œè§£å‹ç¼©æµ‹è¯•...', 'info');

            try {
                const originalData = {
                    user: 'John Doe',
                    profile: 'test_profile_data'.repeat(100),
                    settings: {
                        theme: 'dark',
                        language: 'zh-CN',
                        notifications: true
                    }
                };

                // First compress
                const compressed = compressionUtils.compress(originalData);

                if (!compressed.success) {
                    setResult('compression-result', 'âŒ å‹ç¼©å¤±è´¥ï¼Œæ— æ³•è¿›è¡Œè§£å‹ç¼©æµ‹è¯•', 'error');
                    recordTest(false);
                    return;
                }

                // Then decompress
                const startTime = performance.now();
                const decompressed = compressionUtils.decompress(compressed.data);
                const endTime = performance.now();

                const decompressionTime = (endTime - startTime).toFixed(2);

                // Verify data integrity
                const integrityCheck = JSON.stringify(decompressed) === JSON.stringify(originalData);

                const output = `
${integrityCheck ? 'âœ…' : 'âŒ'} è§£å‹ç¼©æµ‹è¯•

åŸå§‹æ•°æ®: ${JSON.stringify(originalData, null, 2)}
è§£å‹ç¼©æ•°æ®: ${JSON.stringify(decompressed, null, 2)}
æ•°æ®å®Œæ•´æ€§: ${integrityCheck ? 'é€šè¿‡' : 'å¤±è´¥'}
è§£å‹ç¼©æ—¶é—´: ${decompressionTime} æ¯«ç§’
ä½¿ç”¨çš„ç®—æ³•: ${compressed.algorithm}
                `.trim();

                setResult('compression-result', output, integrityCheck ? 'success' : 'error');
                recordTest(integrityCheck);
            } catch (error) {
                setResult('compression-result', `âŒ æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                recordTest(false);
            }

            updateStatus('compression', 'success');
        }

        async function runEdgeCaseTest() {
            updateStatus('compression', 'running');
            setResult('compression-result', 'æ­£åœ¨è¿è¡Œè¾¹ç•Œæƒ…å†µæµ‹è¯•...', 'info');

            try {
                const edgeCases = [
                    { name: 'ç©ºå­—ç¬¦ä¸²', data: '' },
                    { name: 'nullå€¼', data: null },
                    { name: 'undefinedå€¼', data: undefined },
                    { name: 'æ•°å­—', data: 12345 },
                    { name: 'å¸ƒå°”å€¼', data: true },
                    { name: 'ç©ºå¯¹è±¡', data: {} },
                    { name: 'ç©ºæ•°ç»„', data: [] },
                    { name: 'å°å­—ç¬¦ä¸²', data: 'small' }
                ];

                let results = [];
                let passed = 0;

                for (const testCase of edgeCases) {
                    try {
                        const result = compressionUtils.compress(testCase.data);
                        results.push(`${testCase.name}: ${result.success ? 'âœ…' : 'âŒ'} (${result.algorithm || 'none'})`);
                        if (!result.success && testCase.data && typeof testCase.data === 'string' && testCase.data.length > 50) {
                            passed++;
                        } else if (result.success) {
                            passed++;
                        } else if (!testCase.data || (typeof testCase.data === 'string' && testCase.data.length <= 50)) {
                            passed++; // Expected to fail for small/null data
                        }
                    } catch (error) {
                        results.push(`${testCase.name}: âŒ å¼‚å¸¸ - ${error.message}`);
                    }
                }

                const output = `
è¾¹ç•Œæƒ…å†µæµ‹è¯•ç»“æœ:

${results.join('\n')}

é€šè¿‡æµ‹è¯•: ${passed}/${edgeCases.length}
æˆåŠŸç‡: ${(passed / edgeCases.length * 100).toFixed(1)}%
                `.trim();

                setResult('compression-result', output, passed === edgeCases.length ? 'success' : 'info');
                recordTest(passed === edgeCases.length);
            } catch (error) {
                setResult('compression-result', `âŒ æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                recordTest(false);
            }

            updateStatus('compression', 'success');
        }

        async function runNetworkDetectionTest() {
            updateStatus('network', 'running');
            setResult('network-result', 'æ­£åœ¨è¿è¡Œç½‘ç»œæ£€æµ‹æµ‹è¯•...', 'info');

            try {
                const networkInfo = compressionUtils.getNetworkInfo();

                const output = `
âœ… ç½‘ç»œæ£€æµ‹æµ‹è¯•

ç½‘ç»œç±»å‹: ${networkInfo.effectiveType || 'unknown'}
ä¸‹è¡Œå¸¦å®½: ${networkInfo.downlink || 'unknown'} Mbps
RTT: ${networkInfo.rtt || 'unknown'} ms
èŠ‚çœæ•°æ®æ¨¡å¼: ${networkInfo.saveData ? 'å¼€å¯' : 'å…³é—­'}

æ”¯æŒçš„ç½‘ç»œAPI: ${Object.keys(networkInfo).join(', ')}

æµè§ˆå™¨å…¼å®¹æ€§: ${compressionUtils.getBrowserCompatibility().supported ? 'âœ… æ”¯æŒ' : 'âŒ ä¸æ”¯æŒ'}
                `.trim();

                setResult('network-result', output, 'success');
                recordTest(true);
            } catch (error) {
                setResult('network-result', `âŒ æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                recordTest(false);
            }

            updateStatus('network', 'success');
        }

        async function simulateSlowNetwork() {
            updateStatus('network', 'running');
            setResult('network-result', 'æ­£åœ¨æ¨¡æ‹Ÿæ…¢ç½‘ç»œç¯å¢ƒ...', 'info');

            try {
                // Mock slow network
                if (navigator.connection) {
                    const originalConnection = {
                        effectiveType: navigator.connection.effectiveType,
                        downlink: navigator.connection.downlink,
                        saveData: navigator.connection.saveData
                    };

                    navigator.connection.effectiveType = '2g';
                    navigator.connection.downlink = 0.1;
                    navigator.connection.saveData = true;

                    const testData = testHelpers.createTestRepetitiveData();
                    const result = compressionUtils.compress(testData);

                    // Restore original connection
                    Object.assign(navigator.connection, originalConnection);

                    const output = `
âœ… æ…¢ç½‘ç»œæ¨¡æ‹Ÿæµ‹è¯•

æ¨¡æ‹Ÿç½‘ç»œç±»å‹: 2g
æ¨¡æ‹Ÿå¸¦å®½: 0.1 Mbps
æ•°æ®èŠ‚çœæ¨¡å¼: å¼€å¯

å‹ç¼©ç»“æœ:
- æˆåŠŸ: ${result.success}
- å‹ç¼©ç‡: ${(result.compressionRatio * 100).toFixed(1)}%
- ç®—æ³•: ${result.algorithm}
                    `.trim();

                    setResult('network-result', output, 'success');
                    recordTest(true, result.compressionRatio);
                } else {
                    setResult('network-result', 'âŒ æµè§ˆå™¨ä¸æ”¯æŒç½‘ç»œè¿æ¥API', 'error');
                    recordTest(false);
                }
            } catch (error) {
                setResult('network-result', `âŒ æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                recordTest(false);
            }

            updateStatus('network', 'success');
        }

        async function simulateFastNetwork() {
            updateStatus('network', 'running');
            setResult('network-result', 'æ­£åœ¨æ¨¡æ‹Ÿå¿«ç½‘ç»œç¯å¢ƒ...', 'info');

            try {
                // Mock fast network
                if (navigator.connection) {
                    const originalConnection = {
                        effectiveType: navigator.connection.effectiveType,
                        downlink: navigator.connection.downlink,
                        saveData: navigator.connection.saveData
                    };

                    navigator.connection.effectiveType = '4g';
                    navigator.connection.downlink = 50;
                    navigator.connection.saveData = false;

                    const testData = testHelpers.createTestRepetitiveData();
                    const result = compressionUtils.compress(testData);

                    // Restore original connection
                    Object.assign(navigator.connection, originalConnection);

                    const output = `
âœ… å¿«ç½‘ç»œæ¨¡æ‹Ÿæµ‹è¯•

æ¨¡æ‹Ÿç½‘ç»œç±»å‹: 4g
æ¨¡æ‹Ÿå¸¦å®½: 50 Mbps
æ•°æ®èŠ‚çœæ¨¡å¼: å…³é—­

å‹ç¼©ç»“æœ:
- æˆåŠŸ: ${result.success}
- å‹ç¼©ç‡: ${(result.compressionRatio * 100).toFixed(1)}%
- ç®—æ³•: ${result.algorithm}
                    `.trim();

                    setResult('network-result', output, 'success');
                    recordTest(true, result.compressionRatio);
                } else {
                    setResult('network-result', 'âŒ æµè§ˆå™¨ä¸æ”¯æŒç½‘ç»œè¿æ¥API', 'error');
                    recordTest(false);
                }
            } catch (error) {
                setResult('network-result', `âŒ æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                recordTest(false);
            }

            updateStatus('network', 'success');
        }

        async function runNetworkAdaptiveTest() {
            updateStatus('network', 'running');
            setResult('network-result', 'æ­£åœ¨è¿è¡Œè‡ªé€‚åº”å‹ç¼©æµ‹è¯•...', 'info');

            try {
                const testData = testHelpers.createTestRepetitiveData();

                // Test with different network conditions
                const conditions = [
                    { type: 'slow', effectiveType: '2g', saveData: true },
                    { type: 'fast', effectiveType: '4g', saveData: false }
                ];

                let results = [];

                for (const condition of conditions) {
                    if (navigator.connection) {
                        navigator.connection.effectiveType = condition.effectiveType;
                        navigator.connection.saveData = condition.saveData;

                        const result = compressionUtils.compress(testData);
                        results.push(`${condition.type}ç½‘ç»œ: ${result.success ? 'âœ…' : 'âŒ'} (${(result.compressionRatio * 100).toFixed(1)}% å‹ç¼©ç‡)`);
                    }
                }

                const output = `
âœ… è‡ªé€‚åº”å‹ç¼©æµ‹è¯•

${results.join('\n')}

å‹ç¼©ç­–ç•¥å·²æ ¹æ®ç½‘ç»œæ¡ä»¶è‡ªåŠ¨è°ƒæ•´ã€‚
                `.trim();

                setResult('network-result', output, 'success');
                recordTest(true);
            } catch (error) {
                setResult('network-result', `âŒ æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                recordTest(false);
            }

            updateStatus('network', 'success');
        }

        async function testURLSearchParams() {
            updateStatus('format', 'running');
            setResult('format-result', 'æ­£åœ¨æµ‹è¯•URLSearchParamsè½¬æ¢...', 'info');

            try {
                const data = {
                    name: 'John Doe',
                    age: '30',
                    preferences: JSON.stringify({ theme: 'dark' }),
                    tags: ['tag1', 'tag2']
                };

                const result = compressionUtils.compressAndConvert(data, 'urlsearchparams');

                const output = `
${result.success ? 'âœ…' : 'âŒ'} URLSearchParamsè½¬æ¢æµ‹è¯•

åŸå§‹æ•°æ®: ${JSON.stringify(data, null, 2)}
è½¬æ¢æ ¼å¼: ${result.format}
è½¬æ¢æˆåŠŸ: ${result.success}

è½¬æ¢åçš„æ•°æ®å¯ç”¨äºURLå‚æ•°ä¼ é€’ã€‚
                `.trim();

                setResult('format-result', output, result.success ? 'success' : 'error');
                recordTest(result.success);
            } catch (error) {
                setResult('format-result', `âŒ æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                recordTest(false);
            }

            updateStatus('format', 'success');
        }

        async function testFormData() {
            updateStatus('format', 'running');
            setResult('format-result', 'æ­£åœ¨æµ‹è¯•FormDataè½¬æ¢...', 'info');

            try {
                const data = {
                    username: 'testuser',
                    profile: JSON.stringify({ bio: 'test bio' }),
                    files: ['file1.txt', 'file2.txt']
                };

                const result = compressionUtils.compressAndConvert(data, 'formdata');

                const output = `
${result.success ? 'âœ…' : 'âŒ'} FormDataè½¬æ¢æµ‹è¯•

åŸå§‹æ•°æ®: ${JSON.stringify(data, null, 2)}
è½¬æ¢æ ¼å¼: ${result.format}
è½¬æ¢æˆåŠŸ: ${result.success}

è½¬æ¢åçš„æ•°æ®å¯ç”¨äºè¡¨å•æäº¤ã€‚
                `.trim();

                setResult('format-result', output, result.success ? 'success' : 'error');
                recordTest(result.success);
            } catch (error) {
                setResult('format-result', `âŒ æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                recordTest(false);
            }

            updateStatus('format', 'success');
        }

        async function testJSONFormat() {
            updateStatus('format', 'running');
            setResult('format-result', 'æ­£åœ¨æµ‹è¯•JSONæ ¼å¼...', 'info');

            try {
                const data = testHelpers.createTestRepetitiveData();
                const result = compressionUtils.compressAndConvert(data, 'json');

                const output = `
${result.success ? 'âœ…' : 'âŒ'} JSONæ ¼å¼æµ‹è¯•

åŸå§‹æ•°æ®å¤§å°: ${result.originalSize} å­—èŠ‚
JSONæ ¼å¼å¤§å°: ${result.compressedSize} å­—èŠ‚
æ ¼å¼: ${result.format}
å‹ç¼©ç‡: ${(result.compressionRatio * 100).toFixed(1)}%

JSONæ ¼å¼é€‚åˆAPIè°ƒç”¨å’Œæ•°æ®äº¤æ¢ã€‚
                `.trim();

                setResult('format-result', output, result.success ? 'success' : 'error');
                recordTest(result.success, result.compressionRatio);
            } catch (error) {
                setResult('format-result', `âŒ æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                recordTest(false);
            }

            updateStatus('format', 'success');
        }

        async function testStringFormat() {
            updateStatus('format', 'running');
            setResult('format-result', 'æ­£åœ¨æµ‹è¯•å­—ç¬¦ä¸²æ ¼å¼...', 'info');

            try {
                const data = testHelpers.createTestRepetitiveData();
                const result = compressionUtils.compressAndConvert(data, 'string');

                const output = `
${result.success ? 'âœ…' : 'âŒ'} å­—ç¬¦ä¸²æ ¼å¼æµ‹è¯•

åŸå§‹æ•°æ®å¤§å°: ${result.originalSize} å­—èŠ‚
å­—ç¬¦ä¸²æ ¼å¼å¤§å°: ${result.compressedSize} å­—èŠ‚
æ ¼å¼: ${result.format}
å‹ç¼©ç‡: ${(result.compressionRatio * 100).toFixed(1)}%

å­—ç¬¦ä¸²æ ¼å¼é€‚åˆå­˜å‚¨å’Œä¼ è¾“ã€‚
                `.trim();

                setResult('format-result', output, result.success ? 'success' : 'error');
                recordTest(result.success, result.compressionRatio);
            } catch (error) {
                setResult('format-result', `âŒ æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                recordTest(false);
            }

            updateStatus('format', 'success');
        }

        async function runPerformanceBenchmark() {
            updateStatus('performance', 'running');
            setResult('performance-result', 'æ­£åœ¨è¿è¡Œæ€§èƒ½åŸºå‡†æµ‹è¯•...', 'info');

            try {
                const testData = testHelpers.createTestRepetitiveData();
                const iterations = 10;
                const results = [];

                for (let i = 0; i < iterations; i++) {
                    const startTime = performance.now();
                    const result = compressionUtils.compress(testData);
                    const endTime = performance.now();

                    results.push({
                        time: endTime - startTime,
                        success: result.success,
                        ratio: result.compressionRatio
                    });
                }

                const avgTime = results.reduce((sum, r) => sum + r.time, 0) / iterations;
                const minTime = Math.min(...results.map(r => r.time));
                const maxTime = Math.max(...results.map(r => r.time));
                const avgRatio = results.reduce((sum, r) => sum + r.ratio, 0) / iterations;

                const output = `
âœ… æ€§èƒ½åŸºå‡†æµ‹è¯•å®Œæˆ

æµ‹è¯•æ¬¡æ•°: ${iterations}
å¹³å‡æ—¶é—´: ${avgTime.toFixed(2)} æ¯«ç§’
æœ€å¿«æ—¶é—´: ${minTime.toFixed(2)} æ¯«ç§’
æœ€æ…¢æ—¶é—´: ${maxTime.toFixed(2)} æ¯«ç§’
å¹³å‡å‹ç¼©ç‡: ${(avgRatio * 100).toFixed(1)}%

æ€§èƒ½è¯„ä¼°:
${avgTime < 50 ? 'ğŸš€ ä¼˜ç§€' : avgTime < 100 ? 'âœ… è‰¯å¥½' : 'âš ï¸ éœ€è¦ä¼˜åŒ–'}
                `.trim();

                setResult('performance-result', output, 'success');
                recordTest(true, avgRatio);
            } catch (error) {
                setResult('performance-result', `âŒ æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                recordTest(false);
            }

            updateStatus('performance', 'success');
        }

        async function runMemoryTest() {
            updateStatus('performance', 'running');
            setResult('performance-result', 'æ­£åœ¨è¿è¡Œå†…å­˜ä½¿ç”¨æµ‹è¯•...', 'info');

            try {
                const initialMemory = performance.memory ? performance.memory.usedJSHeapSize : 'N/A';

                // Create and compress large data
                const largeDataArray = Array(100).fill().map(() => testHelpers.createTestRepetitiveData());

                for (const data of largeDataArray) {
                    compressionUtils.compress(data);
                }

                const finalMemory = performance.memory ? performance.memory.usedJSHeapSize : 'N/A';

                let memoryIncrease = 'N/A';
                if (typeof initialMemory === 'number' && typeof finalMemory === 'number') {
                    memoryIncrease = ((finalMemory - initialMemory) / 1024 / 1024).toFixed(2) + ' MB';
                }

                const output = `
âœ… å†…å­˜ä½¿ç”¨æµ‹è¯•

åˆå§‹å†…å­˜: ${typeof initialMemory === 'number' ? (initialMemory / 1024 / 1024).toFixed(2) + ' MB' : initialMemory}
å¤„ç†åå†…å­˜: ${typeof finalMemory === 'number' ? (finalMemory / 1024 / 1024).toFixed(2) + ' MB' : finalMemory}
å†…å­˜å¢é•¿: ${memoryIncrease}
å¤„ç†æ•°æ®é‡: ${largeDataArray.length} ä¸ªå¤§å¯¹è±¡

å†…å­˜ç®¡ç†: ${memoryIncrease === 'N/A' || parseFloat(memoryIncrease) < 50 ? 'âœ… æ­£å¸¸' : 'âš ï¸ éœ€è¦å…³æ³¨'}
                `.trim();

                setResult('performance-result', output, 'success');
                recordTest(true);
            } catch (error) {
                setResult('performance-result', `âŒ æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                recordTest(false);
            }

            updateStatus('performance', 'success');
        }

        async function runBatchTest() {
            updateStatus('performance', 'running');
            setResult('performance-result', 'æ­£åœ¨è¿è¡Œæ‰¹é‡æ“ä½œæµ‹è¯•...', 'info');

            try {
                const batchSizes = [10, 50, 100];
                let results = [];

                for (const batchSize of batchSizes) {
                    const testBatch = Array(batchSize).fill().map((_, i) => ({
                        id: i,
                        data: `batch_test_data_${i}`.repeat(10)
                    }));

                    const startTime = performance.now();
                    const batchResults = testBatch.map(data => compressionUtils.compress(data));
                    const endTime = performance.now();

                    const successful = batchResults.filter(r => r.success).length;
                    const totalTime = endTime - startTime;

                    results.push({
                        size: batchSize,
                        time: totalTime.toFixed(2),
                        success: successful,
                        successRate: (successful / batchSize * 100).toFixed(1)
                    });
                }

                const output = `
âœ… æ‰¹é‡æ“ä½œæµ‹è¯•ç»“æœ:

${results.map(r =>
    `${r.size} ä¸ªå¯¹è±¡: ${r.time}ms, ${r.success}/${r.size} æˆåŠŸ (${r.successRate}%)`
).join('\n')}

æ‰¹é‡å¤„ç†æ€§èƒ½è¡¨ç°è‰¯å¥½ã€‚
                `.trim();

                setResult('performance-result', output, 'success');
                recordTest(true);
            } catch (error) {
                setResult('performance-result', `âŒ æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                recordTest(false);
            }

            updateStatus('performance', 'success');
        }

        async function showPerformanceStats() {
            updateStatus('performance', 'running');
            setResult('performance-result', 'æ­£åœ¨è·å–æ€§èƒ½ç»Ÿè®¡...', 'info');

            try {
                const stats = compressionUtils.getStats();
                const metrics = compressionUtils.getPerformanceMetrics();
                const config = compressionUtils.getConfig();

                const output = `
âœ… æ€§èƒ½ç»Ÿè®¡ä¿¡æ¯

åŸºæœ¬ç»Ÿè®¡:
- æ€»å‹ç¼©æ¬¡æ•°: ${stats.totalCompressions}
- æˆåŠŸå‹ç¼©: ${stats.successfulCompressions}
- æˆåŠŸç‡: ${stats.successRate ? (stats.successRate * 100).toFixed(1) + '%' : 'N/A'}

å‹ç¼©æ•ˆæœ:
- æ€»åŸå§‹å¤§å°: ${stats.totalOriginalSize} å­—èŠ‚
- æ€»å‹ç¼©å¤§å°: ${stats.totalCompressedSize} å­—èŠ‚
- èŠ‚çœç©ºé—´: ${stats.spaceSaved} å­—èŠ‚
- å¹³å‡å‹ç¼©ç‡: ${stats.overallCompressionRatio ? (stats.overallCompressionRatio * 100).toFixed(1) + '%' : 'N/A'}

æ€§èƒ½æŒ‡æ ‡:
- å¹³å‡å‹ç¼©æ—¶é—´: ${stats.averageCompressionTime.toFixed(2)} æ¯«ç§’

å½“å‰é…ç½®:
- æœ€å°å‹ç¼©ç‡: ${(config.minCompressionRatio * 100).toFixed(1)}%
- å¯ç”¨å›é€€: ${config.enableFallback ? 'æ˜¯' : 'å¦'}
- ä¼˜å…ˆæœ€å°: ${config.preferSmallest ? 'æ˜¯' : 'å¦'}
- ç®—æ³•: ${config.algorithm}
                `.trim();

                setResult('performance-result', output, 'success');
                recordTest(true);
            } catch (error) {
                setResult('performance-result', `âŒ è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥: ${error.message}`, 'error');
                recordTest(false);
            }

            updateStatus('performance', 'success');
        }

        // Test helpers (similar to those in test-setup.js)
        window.testHelpers = {
            createTestRepetitiveData: function() {
                return {
                    message: 'test_message_12345'.repeat(2000),
                    content: 'A'.repeat(5000),
                    details: {
                        pattern: 'repeated_pattern_xyz'.repeat(1000),
                        metadata: 'x'.repeat(3000)
                    }
                };
            }
        };
    </script>
</body>
</html>